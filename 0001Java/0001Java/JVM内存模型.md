# JVM

关于JVM相关总结

```shell
内存模型

包括

类加载子系统
BootStrapClassLoader
ExtClassLoader
AppClassLoader
MyClassLoader

运行时数据区
5部分


字节码执行引擎
  

```

```shell
类加载子系统

加载
 	 读取class文件加载至-方法区（元空间）

验证
	验证安全
	
准备
	静态变量分配空间 并给默认值（基本类型+引用）

解析
	将符号引用替换为直接引用
		静态链接：（类加载期间完成）
			会把一些静态方法 替换为指向数据所存内存的指针或句柄等（直接引用）
		动态链接：
			程序运行期间完成的将符号引用替换为直接引用

初始化
	对类的静态变量初始化为指定的值，执行静态代码块



双亲委派机制
一般从应用类加载器 会逐步向上委派确认是否加载class
若启动类加载器 没有加载该类 则向下ExtClassLoader
若无 则应用类加载器

若 存在 则直接使用


避免类的重复加载 保证了类的唯一性
沙箱安全机制 避免对Java 核心API修改


打破双亲委托机制
Tomcat
```

```shell
运行时数据区

堆
老年代
	
年轻代
	S0 S1
	Eden
调优参数
	-Xmx
	-Xms
	-Xmn

方法区 元空间
 	常量 静态变量 类元信息
 	
栈
	每个线程独享
	调优参数：-Xss

本地方法栈
	每个线程独享

程序计数器


```

```shell
垃圾回收相关

	分配机制 原则

		大对象直接进入老年代
		
		动态年龄原则
		
		老年代空间分配担保机制
		
		
		
		
		
		
		
		
如何判断引用 标记？
	引用计数器
		有引用则+1
	
	可达性分析
		GC Roots
	
	引用类型分类
		强
		软
		弱
		虚
		
finalize()判读是否标记
	前提：若可达性分析没有GC Roots相关联
	则：
		重写finalize()
			否 直接标记 下次回收
			
		是
    		第二次标记
    	若重新引用 -续命操作
    	
    	
    	

标记方式有哪些

	标记 清除	
		标记 有引用的 清除未引用的  碎片产生
	
	复制 清除
		复制 有应用的 清除未引用的  但是预先会分为两部分
	
	标记 整理 清除
		标记 有引用的 并 依次 移动 最后清除 没有碎片
```



```shell
收集器
Serial


parallel scavenge


parNew


CMS 并发 标记 清除

初始标记 标记 GC Roots 根 非常快
并发标记 根据 GC Roots 关联查找
重新标记（最终标记）重新标记并发标记过程重新需要标记的
并发清除 开始GC 但是会有浮动xx产生
并发重置 

若失败 则会直接STW 使用Serial

Manjor GC
Full GC


G1 
保留了 老年代 年轻代 增加了大对象H 
但是 不作区分 还会相互转换 region
region/个 = 内存/2048

E S O H


初始标记
并发标记
重新标记
筛选回收
```

```shell
常用日志调优命令
调优思路原则
jamp
jstat
jstack
```

